# 150 剩余空间、已使用空间、总空间

Swift

```
extension UIDevice {
    
    func MBFormatter(_ bytes: Int64) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = ByteCountFormatter.Units.useMB
        formatter.countStyle = ByteCountFormatter.CountStyle.decimal
        formatter.includesUnit = false
        return formatter.string(fromByteCount: bytes) as String
    }
    
    //MARK: Get String Value
    var totalDiskSpaceInGB:String {
       return ByteCountFormatter.string(fromByteCount: totalDiskSpaceInBytes, countStyle: ByteCountFormatter.CountStyle.decimal)
    }
    
    var freeDiskSpaceInGB:String {
        return ByteCountFormatter.string(fromByteCount: freeDiskSpaceInBytes, countStyle: ByteCountFormatter.CountStyle.decimal)
    }
    
    var usedDiskSpaceInGB:String {
        return ByteCountFormatter.string(fromByteCount: usedDiskSpaceInBytes, countStyle: ByteCountFormatter.CountStyle.decimal)
    }
    
    var totalDiskSpaceInMB:String {
        return MBFormatter(totalDiskSpaceInBytes)
    }
    
    var freeDiskSpaceInMB:String {
        return MBFormatter(freeDiskSpaceInBytes)
    }
    
    var usedDiskSpaceInMB:String {
        return MBFormatter(usedDiskSpaceInBytes)
    }
    
    //MARK: Get raw value
    var totalDiskSpaceInBytes:Int64 {
        guard let systemAttributes = try? FileManager.default.attributesOfFileSystem(forPath: NSHomeDirectory() as String),
            let space = (systemAttributes[FileAttributeKey.systemSize] as? NSNumber)?.int64Value else { return 0 }
        return space
    }
    
    /*
     Total available capacity in bytes for "Important" resources, including space expected to be cleared by purging non-essential and cached resources. "Important" means something that the user or application clearly expects to be present on the local system, but is ultimately replaceable. This would include items that the user has explicitly requested via the UI, and resources that an application requires in order to provide functionality.
     Examples: A video that the user has explicitly requested to watch but has not yet finished watching or an audio file that the user has requested to download.
     This value should not be used in determining if there is room for an irreplaceable resource. In the case of irreplaceable resources, always attempt to save the resource regardless of available capacity and handle failure as gracefully as possible.
     */
    var freeDiskSpaceInBytes:Int64 {
        if #available(iOS 11.0, *) {
            if let space = try? URL(fileURLWithPath: NSHomeDirectory() as String).resourceValues(forKeys: [URLResourceKey.volumeAvailableCapacityForImportantUsageKey]).volumeAvailableCapacityForImportantUsage {
                return space
            } else {
                return 0
            }
        } else {
            if let systemAttributes = try? FileManager.default.attributesOfFileSystem(forPath: NSHomeDirectory() as String),
            let freeSpace = (systemAttributes[FileAttributeKey.systemFreeSize] as? NSNumber)?.int64Value {
                return freeSpace
            } else {
                return 0
            }
        }
    }
    
    var usedDiskSpaceInBytes:Int64 {
       return totalDiskSpaceInBytes - freeDiskSpaceInBytes
    }
}
```

OC 

UIDevice+DiskSpace.h

```

/**
 * @abstract 获取设备磁盘总容量
 * @return 单位GB
 */
+ (NSString *)totalDiskSpaceInGB;
/**
 * @abstract 获取设备磁盘总容量
 * @return 单位M
 */
+ (NSString *)totalDiskSpaceInMB;
/**
 * @abstract 获取设备磁盘空余容量
 * @return 单位GB
 */
+ (NSString *)freeDiskSpaceInGB;
/**
 * @abstract 获取设备磁盘空余容量
 * @return 单位M
 */
+ (NSString *)freeDiskSpaceInMB;
/**
 * @abstract 获取设备磁盘已使用量
 * @return 单位GB
 */
+ (NSString *)usedDiskSpaceInGB;
/**
 * @abstract 获取设备磁盘已使用量
 * @return 单位M
 */
+ (NSString *)usedDiskSpaceInMB;

```

UIDevice+DiskSpace.m


```
+ (NSString *)totalDiskSpaceInGB
{
    return [NSByteCountFormatter stringFromByteCount:self.totalDiskSpaceInBytes countStyle:NSByteCountFormatterCountStyleDecimal];
}

+ (NSString *)totalDiskSpaceInMB
{
    return [self MBFormatter:self.totalDiskSpaceInBytes];
}

+ (NSString *)freeDiskSpaceInGB
{
    return [NSByteCountFormatter stringFromByteCount:self.freeDiskSpaceInBytes countStyle:NSByteCountFormatterCountStyleDecimal];
}

+ (NSString *)freeDiskSpaceInMB
{
    return [self MBFormatter:self.freeDiskSpaceInBytes];
}

+ (NSString *)usedDiskSpaceInGB
{
    return [NSByteCountFormatter stringFromByteCount:self.usedDiskSpaceInBytes countStyle:NSByteCountFormatterCountStyleDecimal];
}

+ (NSString *)usedDiskSpaceInMB
{
    return [self MBFormatter:self.usedDiskSpaceInBytes];
}

+ (NSString *)MBFormatter:(long long)byte
{
    NSByteCountFormatter * formater = [[NSByteCountFormatter alloc]init];
    formater.allowedUnits = NSByteCountFormatterUseGB;
    formater.countStyle = NSByteCountFormatterCountStyleDecimal;
    formater.includesUnit = false;
    return [formater stringFromByteCount:byte];
}

+ (long)totalDiskSpaceInBytes
{
    NSError * error = nil;
    NSDictionary<NSFileAttributeKey, id> * systemAttributes =  [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];
    if (error) {
        return 0;
    }
    long long space = [systemAttributes[NSFileSystemSize] longLongValue];
    return space;
}

+ (long)freeDiskSpaceInBytes
{
    if (@available(iOS 11.0, *)) {
        [NSURL alloc];
        NSURL * url = [[NSURL alloc]initFileURLWithPath:[NSString stringWithFormat:@"%@",NSHomeDirectory()]];
        NSError * error = nil;
        NSDictionary<NSURLResourceKey, id> * dict = [url resourceValuesForKeys:@[NSURLVolumeAvailableCapacityForImportantUsageKey] error:&error];
        if (error) {
            return 0;
        }
        long long space = [dict[NSURLVolumeAvailableCapacityForImportantUsageKey] longLongValue];
        return space;
    } else {
        NSError * error = nil;
        NSDictionary<NSFileAttributeKey, id> * systemAttributes =  [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];
        if (error) {
            return 0;
        }
        long long space = [systemAttributes[NSFileSystemFreeSize] longLongValue];
        return space;
    }
}

+ (long)usedDiskSpaceInBytes
{
    return self.totalDiskSpaceInBytes - self.freeDiskSpaceInBytes;
}
```

# 151. 查看framework支持的架构

```
lipo -info  /SDK/ShareSDK/ShareSDK.framework/ShareSDK 
// 合并SDK 
// lipo -create  a路径 b路径 -output c路径
```

# 152. use of @import when modules are disabled问题

```
第一步： 点击项目->targets->build settings 搜索module将
1.enable modules
2.link frameworks automatically
两个设置成YES
编译运行，如果问题依然存在那么进入第二步。

第二步：查看项目中是否存在.mm文件，如果存在，可能的原因是您使用objective - c + +。modules不适用c++。于是你有两个选择，1.将@import换成#import。2.不使用objective - c + +
```

# 153. 

```
// https://www.jianshu.com/p/3b68ff32b886
<key>NSUserTrackingUsageDescription</key>
    <string>是否允许我们的APP使用您的IDFA信息，以此来优化您的使用体验，定向提供服务</string>
    
    
- (void)getAdvertisingTrackingAuthority {
    if (@available(iOS 14, *)) {
        ATTrackingManagerAuthorizationStatus status = ATTrackingManager.trackingAuthorizationStatus;
        switch (status) {
            case ATTrackingManagerAuthorizationStatusDenied:
                NSLog(@"用户拒绝IDFA");
                break;
            case ATTrackingManagerAuthorizationStatusAuthorized:
                NSLog(@"用户允许IDFA");
                break;
            case ATTrackingManagerAuthorizationStatusNotDetermined: {
                NSLog(@"用户未做选择或未弹窗IDFA");
                [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) {
                    NSLog(@"app追踪IDFA权限：%lu",(unsigned long)status);
                }];
            }
                break;
            case ATTrackingManagerAuthorizationStatusRestricted: {
                NSLog(@"用户受限制IDFA");
            }
                break;
            default:
                break;
        }
    }
}
```

# 154. advertisingIdentifier

```
#import <AdSupport/AdSupport.h>


BOOL canGet = [[ASIdentifierManager sharedManager] isAdvertisingTrackingEnabled];
NSString *idfa = “”;
if (canGet) {
 idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];
}
```

# 155 预热启动判断

[iOS启动优化之系统预热(prewarm)](https://www.jianshu.com/p/91ed419e3b0c)

```
 func isPrewarmLaunch() -> Bool {
        let systemVersion = UIDevice.current.systemVersion.toFloat() ?? 0.0
        if systemVersion >= 15.0 {
            let environment = ProcessInfo.processInfo.environment
            for key in environment.allKeys() {
                if key.contains(substring: "prewarm") {
                    return true
                }
            }
        }
        return false
    }
```

# 156 公祭日黑白

```
 if (@available(iOS 13.0, *)) {
     UIView *grayView = [[UIView alloc] initWithFrame:UIScreen.mainScreen.bounds];
     grayView.userInteractionEnabled = NO;
     grayView.backgroundColor = [UIColor lightGrayColor];
     grayView.layer.compositingFilter = @"saturationBlendMode";
     grayView.layer.zPosition = CGFLOAT_MAX;
     [self.window addSubview:grayView];
 } else {
     CIFilter *filter = [NSClassFromString(@"CAFilter") filterWithName:@"colorSaturate"];
     [filter setValue:@0 forKey:@"inputAmount"];
     self.window.layer.filters = @[filter];
 }
```

# 157 framework

```
file xx.framework/xx 查看静态库还是动态库
lipo -info xx.framework/xx 指令集
lipo -remove 指令集(x86_64/i386/armv7/arm64) xxx -o xxx xxx为framework文件夹下二进制文件名，删除指令集
xcodebuild -create-xcframework -framework /Users/mac/Downloads/xxx/Debug-iphoneos/xxx.framework -framework /Users/mac/Downloads/xxx/Debug-iphonesimulator/xxx.framework -output /Users/mac/Downloads/xxx/XCFramework/xxx.xcframework 合并
```

# 158 swift weakSelf

```
weak var weakSelf = self
let strongSelf = weakSelf
（注意weakSelf是var修饰的，因为weakSelf释放的时候需要置为nil，所以需要var修饰），然后在闭包内部使用weakSelf，但是使用weakSelf的使用是一个可选类型，需要加上？)

二、在闭包内关键词 in 前面使用加上[weak self] ，代表闭包内部所有的self都是若引用，然后在闭包内部直接使用self即可。对象释放的时候，会将self置为nil，这个也是swift推荐写法，很多第三方都这么写的。对应oc中的__weak typeof(self) weakSelf = self。

三、另外一个写法是[unowned self]，类似于[weak self]，也表示闭包中所有的self都是assign的，不会强引用，但是对象释放，指针地址不会变化，继续调用的话，就会出现野指针，不安全，但是如果能自己管理其内存的话，可以使用，性能效率比[weak self]好，但是一般还是推荐写[weak self]。对应oc中的 __unsafe_unretained typeof(self) weakSelf = self。
```

# 159 CRC32

```
import zlib

let data = Data(base64Encoded: "SGF2ZSBhIG5pY2UgZGF5ISA6KQ==")!
let checksum = data.withUnsafeBytes { crc32(0, $0.bindMemory(to: Bytef.self).baseAddress, uInt(data.count)) }
print("crc32: 0x\(String(format:"%08X", checksum))")
```

# 160 UICollectionViewSectionHeader吸顶

```
flowLayout.sectionHeadersPinToVisibleBounds = YES;
```

# 161 webview获取高度时不准

```
NSString *htmlStr = [NSString stringWithFormat:@"<html><head><meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\"><style type=\"text/css\">img{display: inline-block;max-width: 100%%}</style></head><body>%@</body></html>",html];
    self.viewHeight = 0;
    [self loadHTMLString:htmlStr baseURL:nil];//xlp 修改
//    [self loadHTMLString:html baseURL:[[NSBundle mainBundle]bundleURL]];  //不能这样修改 否则导致富文本不显示
```

# 162 WKWebView获取title

···
[self.webView addObserver:self forKeyPath:@"title" options:NSKeyValueObservingOptionNew context:NULL];
    // KVO 实现方法
    - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {
        if ([keyPath isEqualToString:@"title"] && object == self.webView && self.webView.title.length) {
            NSLog(@"88888 %@", self.webView.title);
            if (!self.titleLabel.text) {
                self.titleLabel.text = self.webView.title;
            }
        }
    }

    - (void)dealloc {
        @try {
            [self.webView removeObserver:self forKeyPath:@"title"];
        } @catch (NSException *exception) {
            
        }
    }
    
    _webView.navigationDelegate = self;
    
    - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
    __strong __typeof(self)weakSelf = self;
    [webView evaluateJavaScript:@"document.title" completionHandler:^(id _Nullable result, NSError * _Nullable error) {
        __strong __typeof(weakSelf)strongSelf = weakSelf;
        NSString *title = result;
        NSLog(@"99999 %@", title);
        if (title.length && !strongSelf.titleLabel.text) {
            strongSelf.titleLabel.text = title;
        }
    }];
}
···